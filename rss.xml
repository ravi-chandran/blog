<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RC Notebook</title><link>https://ravi-chandran.github.io/</link><description>Blog</description><atom:link href="https://ravi-chandran.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:"&gt;Ravi Chandran&lt;/a&gt; 
&lt;br&gt;&lt;a rel="license" href="https://opensource.org/licenses/MIT"&gt;MIT License for Software, &lt;/a&gt;
&lt;a href="http://creativecommons.org/licenses/by/4.0/"&gt;Creative Commons License CC BY 4.0 for other items&lt;/a&gt;
</copyright><lastBuildDate>Sun, 12 Apr 2020 13:40:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Developing With Equipment From Work During The Pandemic</title><link>https://ravi-chandran.github.io/posts/miscellaneous/wifi-router-with-raspberry-pi/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="" src="https://ravi-chandran.github.io/images/miscellaneous/rpi_router.png"&gt;&lt;/p&gt;
&lt;p&gt;With the advent of the disastrous COVID-19, I decided to write this down as a sort of COVID-19 survival tip.&lt;/p&gt;
&lt;p&gt;I've had to take a work project home and set it up in my home office. The work project is an embedded system with a physical Ethernet interface for networking (i.e. no WiFi), and requires internet access. I used an old Raspberry Pi 3 that I had laying around and set it up as a router to get the embedded system onto the internet.&lt;/p&gt;
&lt;p&gt;Here are the steps.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/miscellaneous/wifi-router-with-raspberry-pi/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>iptables</category><category>networking</category><category>Raspberry Pi</category><guid>https://ravi-chandran.github.io/posts/miscellaneous/wifi-router-with-raspberry-pi/</guid><pubDate>Sat, 21 Mar 2020 13:34:05 GMT</pubDate></item><item><title>A Simple Command Timer for Windows</title><link>https://ravi-chandran.github.io/posts/python/a-simple-command-timer-for-windows/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="" src="https://ravi-chandran.github.io/images/python/cmdtimedemo.gif"&gt;&lt;/p&gt;
&lt;p&gt;It's amazing how a trivial search for something that should obviously exist spirals out of control...&lt;/p&gt;
&lt;p&gt;It all started with this. I was tinkering with some Python machine learning scripts which took a while to run, and wanted to know how long they took to run. Unfortunately, I was running my scripts on a Windows command prompt so that Tensorflow could access my PC's NVIDIA GPU. Under Linux via VirtualBox, GPU access doesn't work. Hence my need to use Windows (or get another native Linux machine...)&lt;/p&gt;
&lt;p&gt;Under Linux, there's the well known &lt;code&gt;time&lt;/code&gt; utility that can tell you how long a command took to run. However, I was surprised to find no equivalent utility available in the Windows 10 command prompt. Yes, there are a myriad of solutions for this: use PowerShell, or install Cygwin, or install Bash for Linux, or install one of several old binaries that provide the solution that used to exist on some long-forgotten Windows version. I'm wary of installing anything, especially old binaries of dubious origin. Of course, there's also the more cumbersome approach of simply adding the timing functionality into the Python scripts themselves. It'd be just a few lines of code.&lt;/p&gt;
&lt;p&gt;Hey, why not just create a Python console script that does something like what the Linux &lt;code&gt;time&lt;/code&gt; utility does? It'd only be a few lines of code, right? And so, that's how this little detour started...&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/python/a-simple-command-timer-for-windows/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>PyPI</category><category>pytest</category><category>python</category><category>terminalizer</category><category>Travis CI</category><category>twine</category><guid>https://ravi-chandran.github.io/posts/python/a-simple-command-timer-for-windows/</guid><pubDate>Sun, 08 Mar 2020 18:02:48 GMT</pubDate></item><item><title>Unity ML Agents Installation for Windows</title><link>https://ravi-chandran.github.io/posts/unity/unity-ml-agents-installation-for-windows/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;Here are some notes on how to set up &lt;a href="https://github.com/Unity-Technologies/ml-agents"&gt;Unity ML Agents&lt;/a&gt; under Windows 10. The instructions are consolidated from multiple locations. They've been cleaned up or updated to make sense for the current Unity 2019.30f3 version, the current &lt;a href="https://github.com/Unity-Technologies/ml-agents"&gt;&lt;code&gt;ml-agents&lt;/code&gt;&lt;/a&gt; and Windows 10.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/unity/unity-ml-agents-installation-for-windows/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>machine learning</category><category>ml-agents</category><category>reinforcement learning</category><category>Unity</category><guid>https://ravi-chandran.github.io/posts/unity/unity-ml-agents-installation-for-windows/</guid><pubDate>Sun, 05 Jan 2020 05:00:00 GMT</pubDate></item><item><title>Docker-in-Docker And Proxy Settings</title><link>https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;Docker-in-Docker is explained by its author &lt;a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/"&gt;here&lt;/a&gt;. In a nutshell, the recommendation is to not use "true" Docker-in-Docker. Instead, use:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;docker container run --volume /var/run/docker.sock:/var/run/docker.sock ...
&lt;/pre&gt;


&lt;p&gt;The above volume mapping provides the container with access to the Docker socket with which it can start more "sibling" containers. But the approach is not a "true" Docker-in-Docker (which is not recommended) and avoids its corresponding issues. The nice thing about this approach is it can work with any Docker image (with some additional items installed as explained in this post).&lt;/p&gt;
&lt;p&gt;Here's a compilation of useful proxy settings that may be required if you work in an organization using proxies and require Docker-in-Docker for your work. In addition, I also outline how to update your Dockerfile so that the corresponding image can support this Docker-in-Docker approach. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>apt-get</category><category>build system</category><category>corkscrew</category><category>docker</category><category>docker-in-docker</category><category>git</category><category>npm</category><category>proxy</category><category>wget</category><guid>https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/</guid><pubDate>Sat, 21 Dec 2019 05:00:00 GMT</pubDate></item><item><title>Docker Tricks And Tips</title><link>https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;In a previous &lt;a href="https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/"&gt;post&lt;/a&gt;, I covered an approach for dockerizing a software build system. In this article, I discuss some techniques I've found useful while iterating on a Dockerfile to get it just right. For example, if the Dockerfile involves downloading and installing a 5GB file, each iteration of "&lt;code&gt;docker image build&lt;/code&gt;" could take a lot of time even with good network speeds.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>build system</category><category>docker</category><category>HTTP server</category><guid>https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/</guid><pubDate>Sat, 07 Dec 2019 05:00:00 GMT</pubDate></item><item><title>Dockerizing A Build System</title><link>https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="" src="https://ravi-chandran.github.io/images/docker/business-1845350_640.jpg"&gt;&lt;/p&gt;
&lt;p&gt;After creating a few build systems using Docker recently, I think I have a decent, repeatable approach that's worth writing down. These build systems were used for generating loadable software images for embedded hardware as well as for compiling machine learning algorithms. &lt;/p&gt;
&lt;p&gt;The approach discussed here is about how to create or organize the build system in a way that makes it easy to use and maintain. It's not about the tricks needed to deal with dockerizing any particular software compilers or tools. This approach applies to the common use case of building software by software developers who will be our end users. The build system itself will be abstracted away from our end users so that they can focus on the software.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>build system</category><category>docker</category><guid>https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/</guid><pubDate>Sun, 03 Nov 2019 04:00:00 GMT</pubDate></item><item><title>GitHub Blog Pages Using Nikola</title><link>https://ravi-chandran.github.io/posts/blogging/github-blog-pages-using-nikola/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="" src="https://ravi-chandran.github.io/images/blogging/keyboard-1490036-640x480.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://help.github.com/en/github/working-with-github-pages"&gt;GitHub Pages&lt;/a&gt; can be used to set up your blog for free with a URL like &lt;code&gt;username.github.io&lt;/code&gt; (where &lt;code&gt;username&lt;/code&gt; is your GitHub username). I had to sort through a few combinations of options with GitHub Pages and &lt;a href="https://getnikola.com/"&gt;Nikola&lt;/a&gt; settings. I finally picked one that I found optimal and intuitive.&lt;/p&gt;
&lt;p&gt;Here are my notes in case it's useful for anyone else. Even if you don't use the Nikola static site generator, the options discussed here for GitHub Pages might still be useful.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/blogging/github-blog-pages-using-nikola/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>blog</category><category>GitHub Pages</category><category>Nikola</category><guid>https://ravi-chandran.github.io/posts/blogging/github-blog-pages-using-nikola/</guid><pubDate>Sat, 26 Oct 2019 04:00:00 GMT</pubDate></item></channel></rss>