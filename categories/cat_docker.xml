<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RC Notebook (Posts about docker)</title><link>https://ravi-chandran.github.io/</link><description></description><atom:link href="https://ravi-chandran.github.io/categories/cat_docker.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:"&gt;Ravi Chandran&lt;/a&gt; 
&lt;br&gt;&lt;a rel="license" href="https://opensource.org/licenses/MIT"&gt;MIT License for Software, &lt;/a&gt;
&lt;a href="http://creativecommons.org/licenses/by/4.0/"&gt;Creative Commons License CC BY 4.0 for other items&lt;/a&gt;
</copyright><lastBuildDate>Fri, 10 Jul 2020 15:32:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Docker-in-Docker And Proxy Settings</title><link>https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;Docker-in-Docker is explained by its author &lt;a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/"&gt;here&lt;/a&gt;. In a nutshell, the recommendation is to not use "true" Docker-in-Docker. Instead, use:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;docker container run --volume /var/run/docker.sock:/var/run/docker.sock ...
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The above volume mapping provides the container with access to the Docker socket with which it can start more "sibling" containers. But the approach is not a "true" Docker-in-Docker (which is not recommended) and avoids its corresponding issues. The nice thing about this approach is it can work with any Docker image (with some additional items installed as explained in this post).&lt;/p&gt;
&lt;p&gt;Here's a compilation of useful proxy settings that may be required if you work in an organization using proxies and require Docker-in-Docker for your work. In addition, I also outline how to update your Dockerfile so that the corresponding image can support this Docker-in-Docker approach. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>apt-get</category><category>build system</category><category>corkscrew</category><category>docker</category><category>docker-in-docker</category><category>git</category><category>npm</category><category>proxy</category><category>wget</category><guid>https://ravi-chandran.github.io/posts/docker/docker-in-docker-and-proxy-settings/</guid><pubDate>Sat, 21 Dec 2019 05:00:00 GMT</pubDate></item><item><title>Docker Tricks And Tips</title><link>https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;strong&gt;Please see an adapted version of this article published on &lt;a href="https://opensource.com/article/20/5/optimize-container-builds"&gt;&lt;code&gt;Opensource.com&lt;/code&gt; here&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In a previous &lt;a href="https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/"&gt;post&lt;/a&gt;, I covered an approach for dockerizing a software build system. In this article, I discuss some techniques I've found useful while iterating on a Dockerfile to get it just right. For example, if the Dockerfile involves downloading and installing a 5GB file, each iteration of "&lt;code&gt;docker image build&lt;/code&gt;" could take a lot of time even with good network speeds.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>build system</category><category>docker</category><category>HTTP server</category><guid>https://ravi-chandran.github.io/posts/docker/docker-tricks-and-tips/</guid><pubDate>Sat, 07 Dec 2019 05:00:00 GMT</pubDate></item><item><title>Dockerizing A Build System</title><link>https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/</link><dc:creator>Ravi Chandran</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;strong&gt;Please see the published version of this article on &lt;a href="https://opensource.com/article/20/4/how-containerize-build-system"&gt;&lt;code&gt;Opensource.com&lt;/code&gt; here&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://ravi-chandran.github.io/images/docker/business-1845350_640.jpg"&gt;&lt;/p&gt;
&lt;p&gt;After creating a few build systems using Docker recently, I think I have a decent, repeatable approach that's worth writing down. These build systems were used for generating loadable software images for embedded hardware as well as for compiling machine learning algorithms. &lt;/p&gt;
&lt;p&gt;The approach discussed here is about how to create or organize the build system in a way that makes it easy to use and maintain. It's not about the tricks needed to deal with dockerizing any particular software compilers or tools. This approach applies to the common use case of building software by software developers who will be our end users. The build system itself will be abstracted away from our end users so that they can focus on the software.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>build system</category><category>docker</category><guid>https://ravi-chandran.github.io/posts/docker/dockerizing-a-build-system/</guid><pubDate>Sun, 03 Nov 2019 04:00:00 GMT</pubDate></item></channel></rss>